Adjacency List的儲存形態為data，其中data為一個class，裡面包含兩個資料型態，儲存整數的number以及下一個節點位址的next

第二個class bipartite，裡面有7個data member，整數型態的vertex及edge負責儲存input的內容，而result為一個iterator，作為之後搜尋用
陣列型態有四個，Edge負責儲存每一對邊的兩個節點，Store負責儲存vertex個節點內容，在第一題中，Store存了8列{0,1,2,3,4,5,6,7}的內容
Store2以及Store3則負責儲存V1和V2兩個set。

接著bipartite包含5個function，以下將條列出來介紹
1.Input:
負責接收vertex以及edge數目，並且將每一個edge由哪兩個vertex組成的內容存在Edge中。接著初始化Store的內容。
Store的內容分別為{0,1,2,3,4,5,6,7} {1,0,2,3,4,5,6,7} {2,0,1,3,4,5,6,7} {3,0,1,2,4,5,6,7} {4,0,1,2,3,5,6,7} {5,0,1,2,3,4,6,7} {6,0,1,2,3,4,5,7} {7,0,1,2,3,4,5,6}

2.Operation:
負責建立Adjacency List，將每一個點的相鄰vertex均儲存在Adjacency List這一個陣列中，每一個節點均有number及next這兩個資料

3.Seperate:
負責產生出V1以及V2兩個set，並儲存在Store2和Store3中
此function演算法如下:
將Store的每一個element進行比較，如在檢查Adjacency List時，發現有相連即移除
{0,1,2,3,4,5,6,7}->將和0相接的點移除，所以1和2將會被移除
{0,3,4,5,6,7}->這些點和0都不相接，接著將和3相接的點移除，所以1和2將會被移除，但1和2已被移除
{0,3,4,5,6,7}->接著將和4相接的點移除，所以5將會被移除
{0,3,4,6,7}->接著將和6相接的點移除，所以7將會被移除
{0,3,4,6}->最終結果
{0,3,4,6} {1,2,5,7}分別存在Store2和Store3中
接著
{1,0,2,3,4,5,6,7}->將和1相接的點移除，所以0和3將會被移除
{1,2,4,5,6,7}->這些點和1都不相接，接著將和2相接的點移除，所以0和3將會被移除，但0和3已被移除
{1,2,4,5,6,7}->接著將和4相接的點移除，所以5將會被移除
{1,2,4,6,7}->接著將和6相接的點移除，所以7將會被移除
{1,2,4,6}->最終結果
{0,3,5,7} {1,2,4,6}分別存在Store2和Store3中
以此類推將剩下的{2,0,1,3,4,5,6,7} {3,0,1,2,4,5,6,7} {4,0,1,2,3,5,6,7} {5,0,1,2,3,4,6,7} {6,0,1,2,3,4,5,7} {7,0,1,2,3,4,5,6}做完
其中最後一組將產生{0,3,4,7}{1,2,5,6}這組，為錯誤答案.
以上演算法為O(n+e)

4.Check:
負責將錯誤的答案從陣列中去除
EX:{0,3,4,7}{1,2,5,6}，從Adjacency List中檢查，5和6為相連，所以此組解，將從Store2和Store3中去除
最終Store2和Store3中，將只有{0,3,5,7} {1,2,4,6}以及{0,3,4,6} {1,2,5,7}5這兩組解

5.Show:
負責輸出結果，有解的話輸出true以及V1和V2

最後在main function中，建立物件以及依序呼叫函數:
bipartite a;
a.Input();
a.Operation();
a.Seperate(0);
a.check(0);
a.Show();